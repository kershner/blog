{% extends "/blog/base.html" %}
{% block content %}

<div id="white">
    <div class="container">
	    <div class="row">
		    <div class="col-lg-8 col-lg-offset-2">
			    <img src="/static/images/dogsicon.png"><ba>Tyler Kershner</ba>
				<h2>API Hijinks</h2>
                <bd>September 10th, 2014</bd>
                <hr>
				<p>
                    <strong>In small bits of my spare time I've been investigating the <a href="https://developer.valvesoftware.com/wiki/Steam_Web_API">Steam API</a></strong>.<br><br>
                    I'm looking to eventually make a simple app that will create a word cloud-like visualization of a Steam user's hours played for each game they
                    own.  Well, that's the idea anyway!<br><br>
                    I'll walk through a basic script I've been working on below.
				</p>
                <pre><code data-language="python">import urllib2
import json

# Two different API urls - Steam uses different URLs for different services within the API
API_URL = 'http://api.steampowered.com/IPlayerService/GetOwnedGames/v0001/'
API_URL_STEAMID = 'http://api.steampowered.com/ISteamUser/ResolveVanityURL/v0001/'
API_KEY = 'XXXXXXXXXXXXXXXXXXXXXXXXXXXX'
</code></pre>
                <p>
                    The Steam Web API can output its response in either XML or JSON, and of course I chose JSON because
                    I'm familiar with it, it works well with Python, and it's just plain cleaner than XML.<br><br>
                    As I've noted in the comment, the API uses different URLs for different services.  So you'll end up
                    using one URL for player data and a different one for game data, for example.
                </p>

                <pre><code data-language="python">user_input = raw_input('Enter your steam profile name: > ').lower()

try:
    steam_id = json.loads(urllib2.urlopen('%s?key=%s&vanityurl=%s' %
                                          (API_URL_STEAMID, API_KEY, user_input)).read())['response']['steamid']

    # Don't forget to include_appinfo=1 for extra data about entries
    api_call = urllib2.urlopen('%s?key=%s&steamid=%s&format=json&include_appinfo=1' % (API_URL, API_KEY, steam_id))
    data = json.loads(api_call.read())
</code></pre>
                <p>
                    Here I'm grabbing the user's provided Steam profile name and adding it to the API's SteamID URL
                    to return their corresponding 64-bit Steam ID, which is how the API identifies the user. I should
                    note that in my finalized app I'll need to account for both a Steam vanity URL and the plain 17-digit SteamID as inputs
                    in case the user has not yet established a vanity URL.<br><br>
                    The finalized URL is fed to <a href="https://docs.python.org/2/library/urllib2.html#urllib2.urlopen">urllib2.urlopen()</a> and
                    becomes my actual API call.  The response is then decoded by
                    <a href="https://docs.python.org/2/library/json.html#json.loads">json.loads()</a> and read by Python.
                </p>
    <pre><code data-language="python">
    minutes_played = []

    for game in data['response']['games']:
        minutes_played.append([game['name'], game['playtime_forever']])

    # Using a reverse sort by the 2nd index of each entry in minutes_played
    minutes_played = sorted(minutes_played, key=lambda entry: entry[1], reverse=True)
</code></pre>
                <p>
                    Here I'm extracting a piece of data provided by the API call: the specified user's total playtime (since 2009 when Steam began
                    collecting total playtime data) for the games in their library.  I then use Python's <a href="https://docs.python.org/2/library/functions.html#sorted">sorted()</a>
                    function (with the reverse argument) to create a new list sorted by the index containing the playtime data in descending order.<br><br>
                    In order to sort the list by the correct index (sorting by the game's name would be useless to me!) I had to make use of a yet-unknown concept to me: <a href="https://docs.python.org/2/reference/expressions.html#lambda">Lambda</a>.
                    Lambda is apparently pretty confusing for many aspiring programmers, and I certainly don't fully understand it just yet.  As far as I can gather it's used as an 'anonymous' or
                    'one-off' function as a sort of shortcut to save space/cut down on verbosity within other operations.  I'll be looking into it more to try and wrap my head around it further.
                </p>
    <pre><code data-language="python">
    counter = 0
    print '##################################################'
    print '#   %s\'s Top 5 Most' % user_input
    print '#   Played Steam Games'
    print '##################################################'
    for entry in minutes_played:
        if counter == 5:
            break
        else:
            print '#   ' + str(entry[0]) + ' -- %d hours' % (entry[1] / 60)
            counter += 1
    print '##################################################'

except KeyError:
    print '\nInvalid profile name, please try again.'</code></pre>
                <p>
                    And the final part - the output!  I create a counter variable because for this simple script I only want the top 5
                    most played games to display.  The except clause is there to catch an invalid profile name/ID.<br><br>
                    And here's what the output looks like:
                </p>
    <pre><code>Enter your steam profile name: > billcrystals

##################################################
#   billcrystals's Top 5 Most
#   Played Steam Games
##################################################
#   Left 4 Dead 2 -- 882 hours
#   The Elder Scrolls V: Skyrim -- 200 hours
#   Battlefield: Bad Company 2 -- 128 hours
#   DayZ -- 96 hours
#   Left 4 Dead -- 85 hours
##################################################</code></pre>
                <p>
                    And there you have it!  Apparently I've played entirely too much Left 4 Dead 2.<br><br>I think I've got a great
                    start on this project.  Next up I will be building the algorithm to create the histogram/word cloud-like size variance
                    of the individual game playtimes, and from there it's on to the front end for the website.<br><br>
                    I'll find some time to continue working on the project and hopefully have a completed application to show off soon.<br><br>
                    Thanks for reading!
                </p>

			</div>
        </div><!-- /row -->
	</div>
</div>

<div id="grey">
    <div class="container">
	    <div class="row">
		    <div class="col-lg-8 col-lg-offset-2">
			    <img src="/static/images/dogsicon.png"><ba>Tyler Kershner</ba>
				<h2>Professional?</h2>
                <bd>September 3rd, 2014</bd>
                <hr>
				<p>
                    <strong>Well, roughly six months</strong> after I started teaching myself to program in earnest I'm nearing completion
                    of my first paying gig.  I'm keeping it under wraps for now until it officially launches, but it's a pretty standard
                    webdev job - more or less just setting up a static website, but with the added expectations of a paying client forcing a level of
                    quality and professionalism I haven't yet been required to undertake.  It's a good kind of pressure, and the project
                    is coming along nicely.<br><br>
                    I just wanted to reflect on my progress toward a more satisfying career in computer science and maybe indulge in
                    a little back-patting for a moment.<br><br>
                    Alright, enough of that.  I'm still a crappy amateur programmer, back to work!
				</p>

			</div>
        </div><!-- /row -->
	</div> <!-- /container -->
</div>

<div id="white">
    <div class="container">
	    <div class="row">
		    <div class="col-lg-8 col-lg-offset-2">
			    <img src="/static/images/dogsicon.png"><ba>Tyler Kershner</ba>
				<h2>New Stuff!</h2>
                <bd>August 25th, 2014</bd>
                <hr>
				<p>
                    <strong>I spent most of the weekend developing a new app.</strong><br><br>
                    The creatively named <a href="/scrape_reddit">Reddit Image Scraper</a> pulls image links from a specified subreddit,
                    does a bunch of testing and cleanup behind the scenes using Python, and then displays the acceptable links in a nice, readable grid.
                    The idea is that it will make finding and downloading images
                    from reddit a bit easier than manually sifting through a subreddit's front page. It's great for quickly finding
                    wallpapers.  It was fun to make and good for honing my web development skills.<br><br>
                    The project needs a major design pass, as it looks straight out of 2004 or something, but it is fully functional.
                    I'll be sure to make a new post when I finally get around to making it look professional/sexy.
                    <br><br>
                    Feel free to check it out either at the link below or on its project page.
                    <br><br>
                    <a href="/scrape">Reddit Image Scraper</a>
				</p>

			</div>
        </div><!-- /row -->
	</div> <!-- /container -->
</div>

<div id="grey">
    <div class="container">
	    <div class="row">
		    <div class="col-lg-8 col-lg-offset-2">
			    <img src="/static/images/dogsicon.png"><ba>Tyler Kershner</ba>
				<h2>AJAX</h2>
                <bd>August 18th, 2014</bd>
                <hr>
				<p>
                    <strong>I've had some breakthroughs in the past few weeks.</strong>  As work continued with my <a href="/gif_party">GIF Party</a>
                    project I came to the realization that a core aspect of my GIF projects was pretty flawed according to both efficiency
                    and UX principles.  The auto page refresh using the <strong>http-equiv="refresh"</strong> designation in the <strong>meta</strong> tags was problematic in a number of ways.
                    First, it's extremely resource intensive to force a hard page reload on a set interval.  Secondly it creates the opportunity for the user to be interrupted
                    before being able to complete their interaction with the menu.  I also wanted to add sliders for the user to be able to modify the images' CSS properties
                    and of course any alterations would be lost upon the next page refresh.<br><br>
                    The solution was to make use of an excellent group of techniques referred to as <a href="http://en.wikipedia.org/wiki/Ajax_(programming)">AJAX</a>.<br><br>
                    AJAX stands for <em><strong>Asynchronous Javascript and XML</strong></em>.  It's a way to send and receive data from the server without the need
                    for a client refresh.  Note - technically I'm using <strong>AJAJ</strong>, as the data being transmitted is <a href=http://json.org/">JSON</a> and not <a href="http://en.wikipedia.org/wiki/XML">XML</a>, but the AJAX name persists -
                    it's definitely catchier!
                    This concept allows for much of the dynamic content seen around the web, like new status updates appearing on Facebook without you having to reload the browser.<br><br>
                    AJAX works very well with Flask/Python, especially because of the extremely similar nature of JSON objects and Python dictionaries.  The idea is that you'll have a JavaScript function
                    point to a route in your Flask app.<br>
                </p>
<pre><code data-language="javascript">$(document).ready(function() {
    $SCRIPT_ROOT = &#123;&#123; request.script_root|tojson|safe &#125;&#125;;
    $('#5').click(function() {
		$.getJSON($SCRIPT_ROOT + '/gif_party_json_5',
		function(data) {
			getImages();
    });
});
</code></pre>
                <p>
                    Above is the new function for selecting '5' as the number of GIFs in GIF Party.  First we include a script-root variable so our web application can find our
                    route/view functions no matter where our app lives.  Check the <a href="http://flask.pocoo.org/docs/patterns/jquery/#where-is-my-site">Flask docs for more info</a>.
                    Secondly we're going to bind a <a href="jquery">jQuery</a> event (<strong>click</strong>) to an HTML element ID (<strong>#5</strong>).  When that ID is clicked, the JavaScript function underneath will fire.
                    This function passes the script root path to the jQuery <a href="http://api.jquery.com/jquery.getjson/">.getJSON</a> method which will follow that route and retrieve the data associated with it.  The returned data is then
                    passed to my main GIF Party function, <a href="https://github.com/kershner/blog/blob/master/app/static/js/gif-party.js#L139">getImages()</a>.<br><br>
                    Now lets walk through the code on the Flask side.
                </p>
<pre><code data-language="python">@app.route('/gif_party_json_5')
def gif_party_json_5():
    session['number'] = 5

    data = {
        "number": session['number']
    }

    return jsonify(data)
</code></pre>
                <p>
                    Here I store the user's choice of '5' in their <a href="http://flask.pocoo.org/docs/quickstart/#sessions">session</a> object and return that
                    value as part of a JSON object.  That object gets passed to the getImages() function and the requested number of GIFs are then updated without the need for
                    a hard page refresh. That's it!<br><br>
                    This new way of doing things has vastly reduced the amount of code in my Flask routes file.  It feels much more logical to have the core application functions
                    be the responsibility of the client and the data that those functions rely on safely stored on the server.  <br><br>
                    Another benefit is the much more efficient
                    use of client resources.  I was able to apply this method to my Raspberry Pi Display and the difference it made was remarkable.  By auto-refreshing the page every
                    20 seconds I was causing a huge amount of strain on the weak Raspberry Pi hardware necessitating a restart of the browser every 10 minutes and a hard reboot of the system
                    every two hours.  Using AJAX, not only do the individual GIFs load faster, but the hardware itself no longer gets bogged down by unnecessary page loads.  The
                    ridiculous little device now hums along uninterrupted all night and day, the only hitches caused by the occasional server congestion of my host.<br><br>
                    Here's to learning new things!
                </p>
			</div>
        </div><!-- /row -->
	</div> <!-- /container -->
</div>

<div id="white">
    <div class="container">
	    <div class="row">
		    <div class="col-lg-8 col-lg-offset-2">
			    <img src="/static/images/dogsicon.png"><ba>Tyler Kershner</ba>
				<h2>Housekeeping</h2>
                <bd>August 4th, 2014</bd>
                <hr>
				<p>
                    <strong>As we roll into a new month</strong> I'm working on a number of different projects simultaneously.
                    Primarily I've been working on CSTools, and have been gradually figuring out databases and <a href="http://en.wikipedia.org/wiki/Object-relational_mapping">ORMs</a>
                    and stuff like that.  I'm going to make a post later in the week walking through my database code,
                    but for now I'm just firing off a quick update to bring attention to my adorable little text
                    adventure.  I finally took some time over the weekend to make a standalone
                    version (no Python required) using <a href="http://www.py2exe.org/">py2exe</a>.  You can find a link
                    to the archive on the text adventure's project page, or <a href="/static/distribute/Descent Into Evil.7z">here</a>.
                    Feel free to check out my first attempt at a programming project! FYI - the ending is terrible!<br><br>
                    I also wanted to drop some new photos of my GIF Display somewhere, so they're here as well.  The damn
                    thing still isn't finished yet, but it's at 99.9%.  As always, Kerry and I just need to find the time to paint
                    and style it.  I did some re-engineering on the velcro tabs and the placement of the Pi in order to
                    combat the velcro drooping as the heat from the LCD screen/Pi gradually warm the adhesive, making it
                    less effective.  Everything seems to be in working order now as the GIF Display can comfortably
                    display internet nonsense 24/7.  Anyway, here are some more photos!
				</p>
                <ul class="rig columns-3">
                    <li>
                        <a href="/static/images/gif-display-new-01.png"><img src="/static/images/gif-display-new-01.png" /></a>
                    </li>
                    <li>
                        <a href="/static/images/gif-display-new-02.png"><img src="/static/images/gif-display-new-02.png" /></a>
                    </li>
                    <li>
                        <a href="/static/images/gif-display-new-03.png"><img src="/static/images/gif-display-new-03.png" /></a>
                    </li>
                </ul>
                <ul class="rig columns-3">
                    <li>
                        <a href="/static/images/gif-display-new-04.png"><img src="/static/images/gif-display-new-04.png" /></a>
                    </li>
                    <li>
                        <a href="/static/images/gif-display-new-05.png"><img src="/static/images/gif-display-new-05.png" /></a>
                    </li>
                    <li>
                        <a href="/static/images/gif-display-new-06.png"><img src="/static/images/gif-display-new-06.png" /></a>
                    </li>
                </ul>
			</div>
        </div><!-- /row -->
	</div> <!-- /container -->
</div>

{% endblock %}